/**
 * Generated by Verge3D Puzzles v.3.2.0
 * Fri Jul 17 2020 22:47:01 GMT+0700 (Indochina Time)
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */

'use strict';

(function () {

  // global variables/constants used by puzzles' functions
  var _pGlob = {};

  _pGlob.objCache = {};
  _pGlob.fadeAnnotations = true;
  _pGlob.objClickCallbacks = [];
  _pGlob.pickedObject = '';
  _pGlob.objHoverCallbacks = [];
  _pGlob.hoveredObject = '';
  _pGlob.objMovementInfos = {};
  _pGlob.objDragOverCallbacks = [];
  _pGlob.objDragOverInfoByBlock = {}
  _pGlob.dragMoveOrigins = {};
  _pGlob.dragScaleOrigins = {};
  _pGlob.mediaElements = {};
  _pGlob.loadedFiles = {};
  _pGlob.loadedFile = '';
  _pGlob.animMixerCallbacks = [];
  _pGlob.arHitPoint = new v3d.Vector3(0, 0, 0);
  _pGlob.states = [];
  _pGlob.percentage = 0;
  _pGlob.animateParamUpdate = null;
  _pGlob.openedFile = '';
  _pGlob.xrSessionAcquired = false;
  _pGlob.xrSessionCallbacks = [];
  _pGlob.screenCoords = new v3d.Vector2();
  _pGlob.gamepadIndex = 0;

  _pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
  _pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
  _pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
  _pGlob.MIN_DRAG_SCALE = 10e-4;
  _pGlob.SET_OBJ_ROT_EPS = 1e-8;

  _pGlob.vec2Tmp = new v3d.Vector2();
  _pGlob.vec2Tmp2 = new v3d.Vector2();
  _pGlob.vec3Tmp = new v3d.Vector3();
  _pGlob.vec3Tmp2 = new v3d.Vector3();
  _pGlob.vec3Tmp3 = new v3d.Vector3();
  _pGlob.vec3Tmp4 = new v3d.Vector3();
  _pGlob.eulerTmp = new v3d.Euler();
  _pGlob.eulerTmp2 = new v3d.Euler();
  _pGlob.quatTmp = new v3d.Quaternion();
  _pGlob.quatTmp2 = new v3d.Quaternion();
  _pGlob.mat4Tmp = new v3d.Matrix4();
  _pGlob.planeTmp = new v3d.Plane();
  _pGlob.raycasterTmp = new v3d.Raycaster();
  _pGlob.intervals = {};

  _pGlob.wooProductInfo = {};

  var _pPhysics = {};

  _pPhysics.tickCallbacks = [];
  _pPhysics.syncList = [];

  // internal info
  _pPhysics.collisionData = [];

  // goes to collision callback
  _pPhysics.collisionInfo = {
    objectA: '',
    objectB: '',
    distance: 0,
    positionOnA: [0, 0, 0],
    positionOnB: [0, 0, 0],
    normalOnB: [0, 0, 0]
  };

  var PL = v3d.PL = v3d.PL || {};

  // a more readable alias for PL (stands for "Puzzle Logic")
  v3d.puzzles = PL;

  PL.procedures = PL.procedures || {};

  PL.execInitPuzzles = function (options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
      initOptions: {
        fadeAnnotations: true,
        useBkgTransp: false,
        preserveDrawBuf: false,
        useCompAssets: false,
        useFullscreen: true,
        useCustomPreloader: false,
        preloaderStartCb: function () {},
        preloaderProgressCb: function () {},
        preloaderEndCb: function () {},
      }
    }

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options ?
      options.container : "";




    // utility functions envoked by the HTML puzzles
    function getElements(ids, isParent) {
      var elems = [];
      if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
          elems.push(getElement(ids[i], isParent));
      } else {
        elems.push(getElement(ids, isParent));
      }
      return elems;
    }

    function getElement(id, isParent) {
      var elem;
      if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
          elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
          // if we are on the initialization stage, we still can have access
          // to the container element
          var id = _initGlob.container;
          if (isParent) {
            elem = parent.document.getElementById(id);
          } else {
            elem = document.getElementById(id);
          }
        }
      } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
          elem = parent;
        else
          elem = window;
      } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
          elem = parent.document;
        else
          elem = document;
      } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
          elem = parent.document.body;
        else
          elem = document.body;
      } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
          elem = parent.document.querySelector(id);
        else
          elem = document.querySelector(id);
      } else {
        if (isParent)
          elem = parent.document.getElementById(id);
        else
          elem = document.getElementById(id);
      }
      return elem;
    }



    // setHTMLElemStyle puzzle
    function setHTMLElemStyle(prop, value, ids, isParent) {
      var elems = getElements(ids, isParent);
      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
          continue;
        elem.style[prop] = value;
      }
    }



    // setHTMLElemAttribute puzzle
    function setHTMLElemAttribute(attr, value, ids, isParent) {
      var elems = getElements(ids, isParent);
      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
          continue;
        elem[attr] = value;
      }
    }




    // initPreloader puzzle
    _initGlob.output.initOptions.useCustomPreloader = true;
    _initGlob.output.initOptions.preloaderStartCb = function () {
      _initGlob.percentage = 0;
      (function () {
        setHTMLElemStyle('visibility', 'visible', 'preloader', false);
        setHTMLElemStyle('visibility', 'hidden', 'indexContainer', true);
        setHTMLElemStyle('visibility', 'hidden', 'main-menu', false);
      })();
    };
    _initGlob.output.initOptions.preloaderProgressCb = function (percentage) {
      _initGlob.percentage = percentage;
      (function () {
        setHTMLElemAttribute('innerHTML', String(Math.round(_initGlob.percentage)) + '%', 'percentage', false);
      })();
    };
    _initGlob.output.initOptions.preloaderEndCb = function () {
      _initGlob.percentage = 100;
      (function () {
        setHTMLElemStyle('visibility', 'hidden', 'preloader', false);
        setHTMLElemStyle('visibility', 'visible', 'indexContainer', true);
        setHTMLElemStyle('visibility', 'visible', 'main-menu', false);
        setHTMLElemStyle('visibility', 'block', 'music-div', false);
      })();
    };

    return _initGlob.output;
  }

  PL.init = function (appInstance, initOptions) {
    initOptions = initOptions || {};

    if ('fadeAnnotations' in initOptions) {
      _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
    }

    this.procedures["stop_music"] = stop_music;
    this.procedures["play_music"] = play_music;
    this.procedures["hide icons"] = hide_icons;
    this.procedures["hide_meeting_status"] = hide_meeting_status;
    this.procedures["hide_popups"] = hide_popups;
    this.procedures["hide_quiz"] = hide_quiz;

    var music_state;



    // utility function envoked by almost all V3D-specific puzzles
    // filter off some non-mesh types
    function notIgnoredObj(obj) {
      return (obj.type !== "AmbientLight" && obj.name !== "" &&
        !(obj.isMesh && obj.isMaterialGeneratedMesh));
    }


    // utility function envoked by almost all V3D-specific puzzles
    // find first occurence of the object by its name
    function getObjectByName(objName) {
      var objFound;
      var runTime = _pGlob !== undefined;
      objFound = runTime ? _pGlob.objCache[objName] : null;

      if (objFound && objFound.name === objName)
        return objFound;

      appInstance.scene.traverse(function (obj) {
        if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
          objFound = obj;
          if (runTime) {
            _pGlob.objCache[objName] = objFound;
          }
        }
      });
      return objFound;
    }


    // utility function envoked by almost all V3D-specific puzzles
    // retrieve all objects on the scene
    function getAllObjectNames() {
      var objNameList = [];
      appInstance.scene.traverse(function (obj) {
        if (notIgnoredObj(obj))
          objNameList.push(obj.name)
      });
      return objNameList;
    }


    // utility function envoked by almost all V3D-specific puzzles
    // retrieve all objects which belong to the group
    function getObjectNamesByGroupName(targetGroupName) {
      var objNameList = [];
      appInstance.scene.traverse(function (obj) {
        if (notIgnoredObj(obj)) {
          var groupNames = obj.groupNames;
          if (!groupNames)
            return;
          for (var i = 0; i < groupNames.length; i++) {
            var groupName = groupNames[i];
            if (groupName == targetGroupName) {
              objNameList.push(obj.name);
            }
          }
        }
      });
      return objNameList;
    }


    // utility function envoked by almost all V3D-specific puzzles
    // process object input, which can be either single obj or array of objects, or a group
    function retrieveObjectNames(objNames) {
      var acc = [];
      retrieveObjectNamesAcc(objNames, acc);
      return acc;
    }

    function retrieveObjectNamesAcc(currObjNames, acc) {
      if (typeof currObjNames == "string") {
        acc.push(currObjNames);
      } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++)
          acc.push(newObj[i]);
      } else if (Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++)
          acc.push(newObj[i]);
      } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
          retrieveObjectNamesAcc(currObjNames[i], acc);
      }
    }




    // tweenCamera puzzle
    function tweenCamera(posObjName, targetObjName, duration, doSlot) {

      duration = Math.max(0, duration);

      if (!targetObjName)
        return;
      if (posObjName)
        var posObj = getObjectByName(posObjName);
      else
        var posObj = appInstance.camera;
      var targetObj = getObjectByName(targetObjName);
      if (!posObj || !targetObj)
        return;

      var wPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
      var wTarget = targetObj.getWorldPosition(_pGlob.vec3Tmp2);

      if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween)
          appInstance.controls.tween(wPos, wTarget, duration, doSlot);
      } else { // TODO: static camera, just position it for now
        if (appInstance.camera.parent)
          appInstance.camera.parent.worldToLocal(wPos);
        appInstance.camera.position.copy(wPos);
        appInstance.camera.lookAt(wTarget);
        doSlot();
      }
    }



    // utility functions envoked by the HTML puzzles
    function getElements(ids, isParent) {
      var elems = [];
      if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
          elems.push(getElement(ids[i], isParent));
      } else {
        elems.push(getElement(ids, isParent));
      }
      return elems;
    }

    function getElement(id, isParent) {
      var elem;
      if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
          elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
          // if we are on the initialization stage, we still can have access
          // to the container element
          var id = _initGlob.container;
          if (isParent) {
            elem = parent.document.getElementById(id);
          } else {
            elem = document.getElementById(id);
          }
        }
      } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
          elem = parent;
        else
          elem = window;
      } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
          elem = parent.document;
        else
          elem = document;
      } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
          elem = parent.document.body;
        else
          elem = document.body;
      } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
          elem = parent.document.querySelector(id);
        else
          elem = document.querySelector(id);
      } else {
        if (isParent)
          elem = parent.document.getElementById(id);
        else
          elem = document.getElementById(id);
      }
      return elem;
    }



    // setHTMLElemStyle puzzle
    function setHTMLElemStyle(prop, value, ids, isParent) {
      var elems = getElements(ids, isParent);
      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
          continue;
        elem.style[prop] = value;
      }
    }



    // setTimeout puzzle
    function registerSetTimeout(timeout, callback) {
      window.setTimeout(callback, 1000 * timeout);
    }



    // eventHTMLElem puzzle
    function eventHTMLElem(eventType, ids, isParent, callback) {
      var elems = getElements(ids, isParent);
      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
          continue;
        elem.addEventListener(eventType, callback, false);
      }
    }



    // show and hide puzzles
    function changeVis(objNames, bool) {
      objNames = retrieveObjectNames(objNames);
      if (!objNames)
        return;
      for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
          continue;
        var obj = getObjectByName(objName);
        if (!obj)
          continue;
        obj.visible = bool;
      }
    }




    /**
     * Retrieve coordinate system from the loaded scene
     */
    function getCoordSystem() {
      var scene = appInstance.scene;

      if (scene && "v3d" in scene.userData && "coordSystem" in scene.userData.v3d) {
        return scene.userData.v3d.coordSystem;
      } else {
        // COMPAT: <2.17, consider replacing to 'Y_UP_RIGHT' for scenes with unknown origin
        return 'Z_UP_RIGHT';
      }
    }


    /**
     * Transform coordinates from one space to another
     * Can be used with Vector3 or Euler.
     */
    function coordsTransform(coords, from, to, noSignChange) {

      if (from == to)
        return coords;

      var y = coords.y,
        z = coords.z;

      if (from == 'Z_UP_RIGHT' && to == 'Y_UP_RIGHT') {
        coords.y = z;
        coords.z = noSignChange ? y : -y;
      } else if (from == 'Y_UP_RIGHT' && to == 'Z_UP_RIGHT') {
        coords.y = noSignChange ? z : -z;
        coords.z = y;
      } else {
        console.error('coordsTransform: Unsupported coordinate space');
      }

      return coords;
    }


    /**
     * Verge3D euler rotation to Blender/Max shortest.
     * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Max default
     *    order) via reversion: XYZ -> ZYX
     * 2) swizzle ZYX->YZX
     * 3) choose the shortest rotation to resemble Blender's behavior
     */
    var eulerV3DToBlenderShortest = function () {

      var eulerTmp = new v3d.Euler();
      var eulerTmp2 = new v3d.Euler();
      var vec3Tmp = new v3d.Vector3();

      return function (euler, dest) {

        var eulerBlender = eulerTmp.copy(euler).reorder('YZX');
        var eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();

        var len = eulerBlender.toVector3(vec3Tmp).lengthSq();
        var lenAlt = eulerBlenderAlt.toVector3(vec3Tmp).lengthSq();

        dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
        return coordsTransform(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
      }

    }();




    function RotationInterface() {
      /**
       * For user manipulations use XYZ extrinsic rotations (which
       * are the same as ZYX intrinsic rotations)
       *     - Blender/Max/Maya use extrinsic rotations in the UI
       *     - XYZ is the default option, but could be set from
       *       some order hint if exported
       */
      this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
      this._actualRotation = new v3d.Euler();
    }

    Object.assign(RotationInterface, {
      initObject: function (obj) {
        if (obj.userData.v3d.puzzles === undefined) {
          obj.userData.v3d.puzzles = {}
        }
        if (obj.userData.v3d.puzzles.rotationInterface === undefined) {
          obj.userData.v3d.puzzles.rotationInterface = new RotationInterface();
        }

        var rotUI = obj.userData.v3d.puzzles.rotationInterface;
        rotUI.updateFromObject(obj);
        return rotUI;
      }
    });

    Object.assign(RotationInterface.prototype, {

      updateFromObject: function (obj) {
        var SYNC_ROT_EPS = 1e-8;

        if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
          this._actualRotation.copy(obj.rotation);
          this._updateUserRotFromActualRot();
        }
      },

      getActualRotation: function (euler) {
        return euler.copy(this._actualRotation);
      },

      setUserRotation: function (euler) {
        // don't copy the order, since it's fixed to ZYX for now
        this._userRotation.set(euler.x, euler.y, euler.z);
        this._updateActualRotFromUserRot();
      },

      getUserRotation: function (euler) {
        return euler.copy(this._userRotation);
      },

      _updateUserRotFromActualRot: function () {
        var order = this._userRotation.order;
        this._userRotation.copy(this._actualRotation).reorder(order);
      },

      _updateActualRotFromUserRot: function () {
        var order = this._actualRotation.order;
        this._actualRotation.copy(this._userRotation).reorder(order);
      }

    });




    // getObjTransform puzzle
    function getObjTransform(objName, mode, coord) {
      if (!objName)
        return;
      var obj = getObjectByName(objName);
      if (!obj)
        return;

      var coordSystem = getCoordSystem();

      var transformVal = 0;

      if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
        transformVal = eulerV3DToBlenderShortest(obj.rotation,
          _pGlob.eulerTmp)[coord];
      } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
        // Maya coordinates
        // Use separate rotation interface to fix ambiguous rotations for Maya,
        // might as well do the same for Blender/Max.

        var rotUI = RotationInterface.initObject(obj);
        transformVal = rotUI.getUserRotation(_pGlob.eulerTmp)[coord];
      } else {
        transformVal = coordsTransform(obj[mode].clone(), 'Y_UP_RIGHT',
          coordSystem, mode === 'scale')[coord];
      }

      if (mode === 'rotation') {
        transformVal = v3d.MathUtils.radToDeg(transformVal);
      }

      return transformVal;
    }




    function initGetCameraDirection() {
      var coordsCallback = function (event) {
        event.preventDefault();

        var xNorm = 0,
          yNorm = 0;
        if (event instanceof MouseEvent) {
          xNorm = event.offsetX / elem.clientWidth;
          yNorm = event.offsetY / elem.clientHeight;
        } else if (event instanceof TouchEvent) {
          var rect = elem.getBoundingClientRect();
          xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
          yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
        }

        _pGlob.screenCoords.x = xNorm * 2 - 1;
        _pGlob.screenCoords.y = -yNorm * 2 + 1;
      }

      var elem = appInstance.container;
      elem.addEventListener('mousemove', coordsCallback);
      elem.addEventListener('mousedown', coordsCallback);
      elem.addEventListener('mouseup', coordsCallback);
      elem.addEventListener('touchstart', coordsCallback);
      elem.addEventListener('touchend', coordsCallback);

    };

    initGetCameraDirection();




    // getCameraDirection puzzle
    var getCameraDirection = function () {

      var coords = new v3d.Vector2();
      var raycaster = new v3d.Raycaster();
      var vec = new v3d.Vector3();

      return function getCameraDirection(useMouseTouch, inverted) {
        var camera = appInstance.camera;

        if (useMouseTouch) {

          if (inverted) {
            coords.x = -_pGlob.screenCoords.x;
            coords.y = -_pGlob.screenCoords.y;
          } else {
            coords.x = _pGlob.screenCoords.x;
            coords.y = _pGlob.screenCoords.y;
          }

          raycaster.setFromCamera(coords, camera);
          var dir = raycaster.ray.direction;

        } else {
          var dir = camera.getWorldDirection(vec);
        }

        return coordsTransform(dir, 'Y_UP_RIGHT', getCoordSystem()).toArray();
      }
    }();



    // setObjTransform puzzle
    function setObjTransform(objNames, mode, x, y, z, offset) {

      objNames = retrieveObjectNames(objNames);
      if (!objNames) return;

      function setObjProp(obj, prop, val) {
        if (!offset) {
          obj[mode][prop] = val;
        } else {
          if (mode != "scale")
            obj[mode][prop] += val;
          else
            obj[mode][prop] *= val;
        }
      }

      var inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''),
        Number(z !== ''));
      var coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

      if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.Math.DEG2RAD);
      }

      var coordSystem = getCoordSystem();

      coordsTransform(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
      coordsTransform(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

      for (var i = 0; i < objNames.length; i++) {

        var objName = objNames[i];
        if (!objName) continue;

        var obj = getObjectByName(objName);
        if (!obj) continue;

        if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
          // Blender/Max coordinates

          // need all the rotations for order conversions, especially if some
          // inputs are not specified
          var euler = eulerV3DToBlenderShortest(obj.rotation, _pGlob.eulerTmp);
          coordsTransform(euler, coordSystem, 'Y_UP_RIGHT');

          if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
          if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
          if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

          /**
           * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
           * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
           */
          euler.order = "YZX";
          euler.reorder(obj.rotation.order);
          obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
          // Maya coordinates

          // Use separate rotation interface to fix ambiguous rotations for Maya,
          // might as well do the same for Blender/Max.

          var rotUI = RotationInterface.initObject(obj);
          var euler = rotUI.getUserRotation(_pGlob.eulerTmp);
          // TODO(ivan): this probably needs some reasonable wrapping
          if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
          if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
          if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

          rotUI.setUserRotation(euler);
          rotUI.getActualRotation(obj.rotation);
        } else {

          if (inputsUsed.x) setObjProp(obj, "x", coords.x);
          if (inputsUsed.y) setObjProp(obj, "y", coords.y);
          if (inputsUsed.z) setObjProp(obj, "z", coords.z);

        }

        obj.updateMatrixWorld(true);
      }

    }



    // outline puzzle
    function outline(objNames, doWhat) {
      objNames = retrieveObjectNames(objNames);
      if (!objNames)
        return;
      if (!appInstance.postprocessing || !appInstance.postprocessing.outlinePass)
        return;
      var outlineArray = appInstance.postprocessing.outlinePass.selectedObjects;
      for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        var obj = getObjectByName(objName);
        if (!obj)
          continue;
        if (doWhat == "ENABLE") {
          if (outlineArray.indexOf(obj) == -1)
            outlineArray.push(obj);
        } else {
          var index = outlineArray.indexOf(obj);
          if (index > -1)
            outlineArray.splice(index, 1);
        }
      }
    }



    // utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
    function initObjectPicking(callback, eventType, mouseDownUseTouchStart) {

      var elem = appInstance.renderer.domElement;
      elem.addEventListener(eventType, pickListener);
      if (eventType == "mousedown") {
        var touchEventName = mouseDownUseTouchStart ? "touchstart" : "touchend";
        elem.addEventListener(touchEventName, pickListener);
      }

      var raycaster = new v3d.Raycaster();

      function pickListener(event) {
        event.preventDefault();

        var xNorm = 0,
          yNorm = 0;
        if (event instanceof MouseEvent) {
          xNorm = event.offsetX / elem.clientWidth;
          yNorm = event.offsetY / elem.clientHeight;
        } else if (event instanceof TouchEvent) {
          var rect = elem.getBoundingClientRect();
          xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
          yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
        }

        _pGlob.screenCoords.x = xNorm * 2 - 1;
        _pGlob.screenCoords.y = -yNorm * 2 + 1;
        raycaster.setFromCamera(_pGlob.screenCoords, appInstance.camera);
        var objList = [];
        appInstance.scene.traverse(function (obj) {
          objList.push(obj);
        });
        var intersects = raycaster.intersectObjects(objList);
        if (intersects.length > 0) {
          var obj = intersects[0].object;
          callback(obj, event);
        } else {
          callback(null, event);
        }
      }
    }

    // utility function used by the whenDraggedOver puzzles
    function fireObjectPickingCallbacks(objName, source, index, cbParam) {
      for (var i = 0; i < source.length; i++) {
        var cb = source[i];
        if (objectsIncludeObj([cb[0]], objName)) {
          cb[index](cbParam);
        }
      }
    }

    function objectsIncludeObj(objNames, testedObjName) {
      if (!testedObjName) return false;

      for (var i = 0; i < objNames.length; i++) {
        if (testedObjName == objNames[i]) {
          return true;
        } else {
          // also check children which are auto-generated for multi-material objects
          var obj = getObjectByName(objNames[i]);
          if (obj && obj.type == "Group") {
            for (var j = 0; j < obj.children.length; j++) {
              if (testedObjName == obj.children[j].name) {
                return true;
              }
            }
          }
        }
      }
      return false;
    }

    // utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
    function getPickedObjectName(obj) {
      // auto-generated from a multi-material object, use parent name instead
      if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
        return obj.parent.name;
      } else {
        return obj.name;
      }
    }



    // whenHovered puzzle
    initObjectPicking(function (obj) {

      var prevHovered = _pGlob.hoveredObject;
      var currHovered = obj ? getPickedObjectName(obj) : "";

      if (prevHovered == currHovered) return;

      // first - all "out" callbacks, then - all "over"
      _pGlob.objHoverCallbacks.forEach(function (el) {
        if (objectsIncludeObj(el.objNames, prevHovered)) {
          // ensure the correct value of the hoveredObject block
          _pGlob.hoveredObject = prevHovered;
          el.callbacks[1]();
        }
      });

      _pGlob.objHoverCallbacks.forEach(function (el) {
        if (objectsIncludeObj(el.objNames, currHovered)) {
          // ensure the correct value of the hoveredObject block
          _pGlob.hoveredObject = currHovered;
          el.callbacks[0]();
        }
      });

      _pGlob.hoveredObject = currHovered;
    }, 'mousemove');



    // whenHovered puzzle
    function registerOnHover(objNames, callback_over, callback_out) {
      objNames = retrieveObjectNames(objNames) || [];
      var objNamesFiltered = objNames.filter(function (name) {
        return name;
      });

      _pGlob.objHoverCallbacks.push({
        objNames: objNamesFiltered,
        callbacks: [callback_over, callback_out]
      });
    }



    // whenClicked puzzle
    initObjectPicking(function (obj) {

      // save the object for the pickedObject block
      _pGlob.pickedObject = obj ? getPickedObjectName(obj) : '';

      _pGlob.objClickCallbacks.forEach(function (el) {
        var isPicked = obj && objectsIncludeObj(el.objNames, getPickedObjectName(obj));
        el.callbacks[isPicked ? 0 : 1]();
      });
    }, 'mousedown');



    // whenClicked puzzle
    function registerOnClick(objNames, cbDo, cbIfMissedDo) {
      objNames = retrieveObjectNames(objNames) || [];
      var objNamesFiltered = objNames.filter(function (name) {
        return name;
      });
      _pGlob.objClickCallbacks.push({
        objNames: objNamesFiltered,
        callbacks: [cbDo, cbIfMissedDo]
      });
    }



    // openWebPage puzzle
    function openWebPage(url, mode) {

      if (appInstance.controls) {
        appInstance.controls.dispose();
        appInstance.enableControls();
      }

      if (mode == "NEW") {
        window.open(url);
      } else if (mode == "NO_RELOAD") {
        history.pushState('verge3d state', 'verge3d page', url);
      } else {
        var target;
        switch (mode) {
          case "SAME":
            target = "_self";
            break;
          case "TOP":
            target = "_top";
            break;
          case "PARENT":
            target = "_parent";
            break;
        }
        if (typeof window.PE != "undefined") {
          if (window.confirm("Are you sure you want to leave Puzzles?"))
            window.open(url, target);
        } else {
          window.open(url, target);
        }
      }
    }


    // Describe this function...
    function stop_music() {}


    /**
     * Retreive standard accessible textures for MeshNodeMaterial,
     * MeshStandardMaterial or MeshPhongMaterial. If "collectSameNameMats" is true
     * then all materials in the scene with the given name will be used for collecting
     * textures, otherwise will be used only the first found material (default behavior).
     */
    function matGetEditableTextures(matName, collectSameNameMats) {

      var mats = [];
      if (collectSameNameMats) {
        mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
      } else {
        var firstMat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
        if (firstMat !== null) {
          mats = [firstMat];
        }
      }

      var textures = mats.reduce(function (texArray, mat) {
        var matTextures = [];
        switch (mat.type) {
          case 'MeshNodeMaterial':
            matTextures = Object.values(mat.nodeTextures);
            break;

          case 'MeshStandardMaterial':
            matTextures = [
              mat.map, mat.lightMap, mat.aoMap, mat.emissiveMap,
              mat.bumpMap, mat.normalMap, mat.displacementMap,
              mat.roughnessMap, mat.metalnessMap, mat.alphaMap, mat.envMap
            ]
            break;

          case 'MeshPhongMaterial':
            matTextures = [
              mat.map, mat.lightMap, mat.aoMap, mat.emissiveMap,
              mat.bumpMap, mat.normalMap, mat.displacementMap,
              mat.specularMap, mat.alphaMap, mat.envMap
            ];
            break;
          default:
            console.error('matGetEditableTextures: Unknown material type ' + mat.type);
            break;
        }

        Array.prototype.push.apply(texArray, matTextures);
        return texArray;
      }, []);

      return textures.filter(function (elem) {
        // check Texture type exactly
        return elem && (elem.constructor == v3d.Texture || elem.constructor == v3d.DataTexture);
      });
    }



    // replaceTexture puzzle
    function replaceTexture(matName, texName, texUrlOrElem, doCb) {

      var textures = matGetEditableTextures(matName, true).filter(function (elem) {
        return elem.name == texName;
      });

      if (!textures.length)
        return;

      if (texUrlOrElem instanceof Promise) {

        texUrlOrElem.then(function (response) {
          processImageUrl(response);
        }, function (error) {});

      } else if (typeof texUrlOrElem == 'string') {

        processImageUrl(texUrlOrElem);

      } else if (texUrlOrElem instanceof HTMLVideoElement) {

        processVideo(texUrlOrElem);

      } else {

        return;

      }

      function processImageUrl(url) {

        var isHDR = (url.search(/\.hdr$/) > 0);

        if (!isHDR) {
          var loader = new v3d.ImageLoader();
          loader.setCrossOrigin('Anonymous');
        } else {
          var loader = new v3d.FileLoader();
          loader.setResponseType('arraybuffer');
        }

        loader.load(url, function (image) {
          // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
          var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;

          textures.forEach(function (elem) {

            if (!isHDR) {
              elem.image = image;
            } else {
              // parse loaded HDR buffer
              var rgbeLoader = new v3d.RGBELoader();
              var texData = rgbeLoader.parse(image);

              // NOTE: reset params since the texture may be converted to float
              elem.type = v3d.UnsignedByteType;
              elem.encoding = v3d.RGBEEncoding;

              elem.image = {
                data: texData.data,
                width: texData.width,
                height: texData.height
              }

              elem.magFilter = v3d.LinearFilter;
              elem.minFilter = v3d.LinearFilter;
              elem.generateMipmaps = false;
              elem.isDataTexture = true;

            }

            elem.format = isJPEG ? v3d.RGBFormat : v3d.RGBAFormat;
            elem.needsUpdate = true;

            // update world material if it is using this texture
            var wMat = appInstance.worldMaterial;
            if (wMat)
              for (var texName in wMat.nodeTextures)
                if (wMat.nodeTextures[texName] == elem)
                  appInstance.updateEnvironment(wMat);

          });

          // exec once
          doCb();

        });
      }

      function processVideo(elem) {
        var videoTex = new v3d.VideoTexture(elem);
        videoTex.flipY = false;
        videoTex.name = texName;

        var videoAssigned = false;

        var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        mats.forEach(function (mat) {

          if (mat.type != 'MeshNodeMaterial')
            return;

          for (var name in mat.nodeTextures) {

            textures.forEach(function (tex) {

              if (mat.nodeTextures[name] == tex) {
                mat.nodeTextures[name] = videoTex;
              }

            });

          }

          mat.needsUpdate = true;
          videoAssigned = true;
        });

        if (videoAssigned)
          doCb();

      }
    }



    // loadVideo puzzle
    function loadVideo(url) {
      var elems = _pGlob.mediaElements;
      if (!(url in elems)) {
        var elem = document.createElement('video');
        elem.src = url;
        elem.playsInline = true;
        elem.preload = 'auto';
        elem.autoload = true;
        elem.crossOrigin = 'anonymous';
        elems[url] = elem;
      }
      return elems[url];
    }



    // playSound puzzle
    function playSound(audioElem, loop) {
      if (!audioElem)
        return;
      audioElem.loop = loop;
      audioElem.play();
    }



    // volume puzzle
    function volume(audioElem, volume) {
      if (!audioElem)
        return;
      if (typeof volume != "number")
        return;
      audioElem.volume = v3d.Math.clamp(volume, 0.0, 1.0);
    }


    // Describe this function...
    function play_music() {}

    // Describe this function...
    function hide_icons() {
      changeVis('Icon_Image_01', false);
      changeVis('Icon_Image_02', false);
      changeVis('Icon_Image_03', false);
      changeVis('Icon_Video_01', false);
      changeVis('Icon_Video_02', false);
    }

    // Describe this function...
    function hide_meeting_status() {
      setHTMLElemStyle('display', 'none', 'meeting-box-status', true);
    }

    // Describe this function...
    function hide_popups() {
      setHTMLElemStyle('display', 'none', 'img-pop-up1', true);
      setHTMLElemStyle('display', 'none', 'img-pop-up2', true);
      setHTMLElemStyle('display', 'none', 'vid-pop-up1', true);
    }

    // Describe this function...
    function hide_quiz() {
      setHTMLElemStyle('display', 'none', 'popup-quiz-1', true);
    }


    eventHTMLElem('click', 'link-view2', false, function (event) {
      hide_popups();
      hide_icons();
      hide_meeting_status();
      tweenCamera('CamPos_02', 'CamTarget_02', 1, function () {});
      registerSetTimeout(1, function () {
        setHTMLElemStyle('display', 'block', 'popup-quiz-1', true);
      });
    });
    eventHTMLElem('click', 'link-view4', false, function (event) {
      hide_meeting_status();
      tweenCamera('CamPos_04', 'CamTarget_04', 1, function () {
        hide_icons();
        changeVis('Icon_Video_01', true);
      });
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
    });
    eventHTMLElem('click', 'link-view7', false, function (event) {
      hide_popups();
      hide_icons();
      tweenCamera('CamPos_07', 'CamTarget_07', 1, function () {});
      registerSetTimeout(1, function () {
        setHTMLElemStyle('display', 'block', 'public-meeting', true);
        setHTMLElemStyle('display', 'block', 'meeting-box-status', true);
      });
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
    });
    eventHTMLElem('click', 'link-view3', false, function (event) {
      hide_meeting_status();
      tweenCamera('CamPos_03', 'CamTarget_03', 1, function () {
        hide_icons();
        changeVis('Icon_Image_02', true);
      });
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
    });
    eventHTMLElem('click', 'link-view8', false, function (event) {
      hide_meeting_status();
      hide_icons();
      tweenCamera('CamPos_07', 'CamTarget_07', 1, function () {});
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
    });
    eventHTMLElem('click', 'link-view5', false, function (event) {
      hide_meeting_status();
      hide_icons();
      tweenCamera('CamPos_05', 'CamTarget_05', 1, function () {});
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
    });
    eventHTMLElem('click', 'link-view10', false, function (event) {
      hide_meeting_status();
      hide_icons();
      tweenCamera('CamPos_10', 'CamTarget_10', 1, function () {});
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
    });
    eventHTMLElem('click', 'home_button', true, function (event) {
      hide_icons();
      hide_meeting_status();
      tweenCamera('CamPos_01', 'CamTarget_01', 1, function () {});
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
    });
    eventHTMLElem('click', 'reps_button', true, function (event) {
      hide_icons();
      hide_popups();
      tweenCamera('CamPos_07', 'CamTarget_07', 1, function () {});
      registerSetTimeout(1, function () {
        setHTMLElemStyle('display', 'block', 'public-meeting', true);
      });
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
    });
    eventHTMLElem('click', 'private_button', true, function (event) {
      hide_meeting_status();
      hide_icons();
      tweenCamera('CamPos_08', 'CamTarget_08', 1, function () {});
      registerSetTimeout(1, function () {
        setHTMLElemStyle('display', 'block', 'private-meeting', true);
      });
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
    });
    eventHTMLElem('click', 'webinar_button', true, function (event) {
      hide_icons();
      hide_meeting_status();
      tweenCamera('CamPos_09', 'CamTarget_09', 1, function () {});
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
    });
    eventHTMLElem('click', 'close-popup1', true, function (event) {
      setHTMLElemStyle('display', 'none', 'img-pop-up1', true);
    });
    eventHTMLElem('click', 'close-popup2', true, function (event) {
      setHTMLElemStyle('display', 'none', 'img-pop-up2', true);
    });
    eventHTMLElem('click', 'close-popup3', true, function (event) {
      setHTMLElemStyle('display', 'none', 'vid-pop-up1', true);
    });
    eventHTMLElem('click', 'close-popup-quiz1', true, function (event) {
      setHTMLElemStyle('display', 'none', 'popup-quiz-1', true);
    });
    eventHTMLElem('click', 'meeting-with-password', true, function (event) {});
    eventHTMLElem('click', 'meeting-without-password', true, function (event) {});
    eventHTMLElem('click', 'close-popup', false, function (event) {
      setHTMLElemStyle('display', 'none', 'popup-html', false);
    });
    eventHTMLElem('click', 'close-popup-2', false, function (event) {
      setHTMLElemStyle('display', 'none', 'popup-html-2', false);
    });
    eventHTMLElem('click', 'zoomout', true, function (event) {
      setObjTransform('Camera', 'position', getObjTransform('Camera', 'position', 'x') + getCameraDirection(false, false)[0] * -0.16, getObjTransform('Camera', 'position', 'y') + getCameraDirection(false, false)[1] * -0.16, getObjTransform('Camera', 'position', 'z') + getCameraDirection(false, false)[2] * -0.16, false);
    });
    eventHTMLElem('click', 'zoomin', true, function (event) {
      setObjTransform('Camera', 'position', getObjTransform('Camera', 'position', 'x') + getCameraDirection(false, false)[0] * 0.16, getObjTransform('Camera', 'position', 'y') + getCameraDirection(false, false)[1] * 0.16, getObjTransform('Camera', 'position', 'z') + getCameraDirection(false, false)[2] * 0.16, false);
    });

    registerOnHover('Icon_02', function () {
      outline('Icon_02', 'ENABLE');
    }, function () {
      outline('Icon_02', 'DISABLE');
    });
    registerOnClick('Icon_02', function () {
      hide_icons();
      hide_meeting_status();
      hide_popups();
      tweenCamera('CamPos_02', 'CamTarget_02', 1, function () {});
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
      registerSetTimeout(1, function () {
        setHTMLElemStyle('display', 'block', 'popup-quiz-1', true);
      });
    }, function () {});
    registerOnHover('Icon_03', function () {
      outline('Icon_03', 'ENABLE');
    }, function () {
      outline('Icon_03', 'DISABLE');
    });
    registerOnClick('Icon_03', function () {
      hide_meeting_status();
      tweenCamera('CamPos_03', 'CamTarget_03', 1, function () {
        hide_icons();
        changeVis('Icon_Image_02', true);
      });
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
    }, function () {});
    registerOnHover('Icon_04', function () {
      outline('Icon_04', 'ENABLE');
    }, function () {
      outline('Icon_04', 'DISABLE');
    });
    registerOnClick('Icon_04', function () {
      hide_meeting_status();
      tweenCamera('CamPos_04', 'CamTarget_04', 1, function () {
        hide_icons();
        changeVis('Icon_Video_01', true);
      });
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
    }, function () {});
    registerOnHover('Icon_05', function () {
      outline('Icon_05', 'ENABLE');
    }, function () {
      outline('Icon_05', 'DISABLE');
    });
    registerOnClick('Icon_05', function () {
      hide_icons();
      hide_meeting_status();
      tweenCamera('CamPos_05', 'CamTarget_05', 1, function () {});
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
    }, function () {});
    registerOnHover('Icon_06', function () {
      outline('Icon_06', 'ENABLE');
    }, function () {
      outline('Icon_06', 'DISABLE');
    });
    registerOnHover('Icon_07', function () {
      outline('Icon_07', 'ENABLE');
    }, function () {
      outline('Icon_07', 'DISABLE');
    });
    registerOnClick('Icon_06', function () {
      hide_icons();
      hide_meeting_status();
      tweenCamera('CamPos_06', 'CamTarget_06', 1, function () {});
      setHTMLElemStyle('display', 'none', 'meeting-buttons', true);
    }, function () {});
    registerOnClick('Icon_07', function () {
      hide_icons();
      tweenCamera('CamPos_07', 'CamTarget_07', 1, function () {});
      registerSetTimeout(1, function () {
        setHTMLElemStyle('display', 'block', 'public-meeting', true);
        setHTMLElemStyle('display', 'block', 'meeting-box-status', true);
      });
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
    }, function () {});
    registerOnHover('Icon_08', function () {
      outline('Icon_08', 'ENABLE');
    }, function () {
      outline('Icon_08', 'DISABLE');
    });
    registerOnClick('Icon_08', function () {
      hide_icons();
      hide_meeting_status();
      tweenCamera('CamPos_08', 'CamTarget_08', 1, function () {});
      registerSetTimeout(1, function () {
        setHTMLElemStyle('display', 'block', 'private-meeting', true);
      });
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
    }, function () {});
    registerOnHover('Icon_09', function () {
      outline('Icon_09', 'ENABLE');
    }, function () {
      outline('Icon_09', 'DISABLE');
    });
    registerOnClick('Icon_09', function () {
      hide_icons();
      hide_meeting_status();
      tweenCamera('CamPos_09', 'CamTarget_09', 1, function () {});
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
    }, function () {});
    registerOnHover('Icon_10', function () {
      outline('Icon_10', 'ENABLE');
    }, function () {
      outline('Icon_10', 'DISABLE');
    });
    registerOnClick('Icon_10', function () {
      hide_icons();
      hide_meeting_status();
      tweenCamera('CamPos_10', 'CamTarget_10', 1, function () {});
      setHTMLElemStyle('display', 'none', 'private-meeting', true);
      setHTMLElemStyle('display', 'none', 'public-meeting', true);
    }, function () {});
    registerOnClick('Car_Body', function () {
      openWebPage('http://fxm.web.id/app/verge3d/Car3/index.html', 'NEW');
      setHTMLElemStyle('display', 'none', 'meeting-buttons', true);
    }, function () {});
    registerOnHover('Car_Body', function () {
      outline('Car_Body', 'ENABLE');
    }, function () {
      outline('Car_Body', 'DISABLE');
    });

    registerOnHover('Icon_Image_01', function () {
      outline('Icon_Image_01', 'ENABLE');
    }, function () {
      outline('Icon_Image_01', 'DISABLE');
    });
    registerOnClick('Icon_Image_01', function () {
      setHTMLElemStyle('display', 'block', 'img-pop-up1', true);
    }, function () {});
    registerOnHover('Icon_Image_02', function () {
      outline('Icon_Image_02', 'ENABLE');
    }, function () {
      outline('Icon_Image_02', 'DISABLE');
    });
    registerOnClick('Icon_Image_02', function () {
      setHTMLElemStyle('display', 'block', 'img-pop-up2', true);
    }, function () {});
    registerOnHover('Icon_Video_01', function () {
      outline('Icon_Video_01', 'ENABLE');
    }, function () {
      outline('Icon_Video_01', 'DISABLE');
    });
    registerOnClick('Icon_Video_01', function () {
      setHTMLElemStyle('display', 'block', 'vid-pop-up1', true);
    }, function () {});

//#disabled     replaceTexture('Poster_01', 'Poster-01.jpg', 'http://fxm.web.id/test/Verge3d/Booth/M01/Poster-01.jpg', function () {});
//#disabled     replaceTexture('Poster_02', 'Poster-02.jpg', 'http://fxm.web.id/test/Verge3d/Booth/M01/Poster-02.jpg', function () {});
//#disabled     replaceTexture('Poster_03', 'Poster-03.jpg', 'http://fxm.web.id/test/Verge3d/Booth/M01/Poster-03.jpg', function () {});
//#disabled     replaceTexture('Video_01', 'Video-01.mp4', loadVideo('http://fxm.web.id/test/Verge3d/Booth/M01/Video-01.mp4'), function () {});

  // #INJECTED
  // timestamp: 1600767403999
  // location: example\visual_logic.js
  if (window !== parent) {
    parent.verge = {
      replacedTextures: [["Poster_01","Poster-01.jpg","http://fxm.web.id/test/Verge3d/Booth/M01/Poster-01.jpg"],["Poster_02","Poster-02.jpg","http://fxm.web.id/test/Verge3d/Booth/M01/Poster-02.jpg"],["Poster_03","Poster-03.jpg","http://fxm.web.id/test/Verge3d/Booth/M01/Poster-03.jpg"],["Video_01","Video-01.mp4","http://fxm.web.id/test/Verge3d/Booth/M01/Video-01.mp4"]],
      replaceTexture: replaceTexture,
      loadVideo: loadVideo,
      volume: volume,
      playSound: playSound
    };
  }
  // #ENDINJECTED
    playSound(loadVideo('http://fxm.web.id/test/Verge3d/Booth/M01/Video-01.mp4'), true);
    volume(loadVideo('http://fxm.web.id/test/Verge3d/Booth/M01/Video-01.mp4'), 0);

  } // end of PL.init function

})(); // end of closure

/* ================================ end of code ============================= */
